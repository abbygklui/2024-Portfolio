{"ast":null,"code":"\n// import React, { useEffect, useRef } from 'react';\n// import * as THREE from 'three';\n// import { FontLoader } from 'three/examples/jsm/loaders/FontLoader.js';\n// import { TextGeometry } from 'three/examples/jsm/geometries/TextGeometry.js';\n// import Navbar from './components/Navbar';\n// import './App.css';\n\n// function App() {\n//   const mountRef = useRef(null);\n\n//   useEffect(() => {\n//     // Vertex Shader\n//     const vertexShader = `\n//       uniform vec3 lightPosition;\n//       varying float vDist;\n\n//       void main() {\n//           vec3 transformedPosition = (modelViewMatrix * vec4(position, 1.0)).xyz;\n\n//           // Calculate the distance from the light source to the vertex\n//           float dist = distance(lightPosition, transformedPosition);\n//           vDist = dist;\n\n//           // Apply a warp based on distance\n//           vec3 direction = normalize(lightPosition - transformedPosition);\n//           vec3 offset = direction * (1.0 / (dist + 0.1)) * 1.2; // Warp effect\n//           transformedPosition += offset;\n\n//           gl_Position = projectionMatrix * vec4(transformedPosition, 1.0);\n//       }\n//     `;\n\n//     // Fragment Shader for Text and Rectangle\n//     const fragmentShader = `\n//       varying float vDist;\n//       uniform vec3 lightColor; // Uniform to receive light color\n//       uniform vec3 baseColor; // Uniform to set the base color (text or rectangle)\n\n//       void main() {\n//           // Calculate intensity based on distance\n//           float intensity = 1.0 / (vDist * vDist + 0.1);\n//           intensity = intensity * 30.0;\n//           intensity = clamp(intensity, 0.0, 1.0);\n\n//           // Apply the light color and intensity to the output color\n//           vec3 color = mix(baseColor, lightColor * intensity, 0.5); // Mix base color with light\n\n//           gl_FragColor = vec4(color, 1.0); // Use the calculated color for the fragment\n//       }\n//     `;\n\n//     // Scene, Camera, Renderer\n//     const scene = new THREE.Scene();\n//     const camera = new THREE.PerspectiveCamera(\n//       75,\n//       window.innerWidth / window.innerHeight,\n//       0.1,\n//       1000\n//     );\n//     const renderer = new THREE.WebGLRenderer({ antialias: true });\n\n//     renderer.setSize(window.innerWidth, window.innerHeight);\n//     mountRef.current.appendChild(renderer.domElement);\n\n//     // Add a point light to act as the dynamic light source\n//     const pointLight = new THREE.PointLight(0xffffff, 2, 100); // White light with increased intensity\n//     pointLight.decay = 1; // Adjust decay for desired falloff\n//     pointLight.castShadow = true;\n//     scene.add(pointLight);\n\n//     // Uniforms for the shader\n//     const uniforms = {\n//       lightPosition: { value: new THREE.Vector3(0, 0, 0) },\n//       lightColor: { value: new THREE.Color(0xffffff) }, // Set light color for interactions\n//     };\n\n//     // Load the font and create the text\n//     const loader = new FontLoader();\n//     loader.load(\n//       'https://threejs.org/examples/fonts/helvetiker_regular.typeface.json',\n//       function (font) {\n//         const textGeometry = new TextGeometry(\n//           'HCI Explorer of digital-physical experiences',\n//           {\n//             font: font,\n//             size: 0.2,\n//             height: 0.0,\n//             curveSegments: 12,\n//             bevelEnabled: false,\n//           }\n//         );\n\n//         textGeometry.computeBoundingBox();\n//         const textWidth =\n//           textGeometry.boundingBox.max.x - textGeometry.boundingBox.min.x;\n//         const textHeight =\n//           textGeometry.boundingBox.max.y - textGeometry.boundingBox.min.y;\n//         const xPosition = -textWidth / 2;\n//         const yPosition = 2.5; // Keep the original vertical position of the text\n\n//         // Create the group for text and background\n//         const textGroup = new THREE.Group();\n\n//         // Create the background rectangle\n//         const backgroundGeometry = new THREE.PlaneGeometry(\n//           textWidth + 0.2, // Slightly larger than the text\n//           textHeight + 0.1\n//         );\n\n//         // Background material using the same shader but with a blue base color\n//         const backgroundMaterial = new THREE.ShaderMaterial({\n//           vertexShader: vertexShader,\n//           fragmentShader: fragmentShader,\n//           uniforms: {\n//             ...uniforms,\n//             baseColor: { value: new THREE.Color(0x000000) }, // Blue base color for the rectangle\n//           },\n//         });\n\n//         const backgroundMesh = new THREE.Mesh(backgroundGeometry, backgroundMaterial);\n//         backgroundMesh.position.set(2.7, 0.1, -0.01); // Adjust the rectangle's position slightly below the text\n\n//         // Text material using the same shader but with a white base color\n//         const textMaterial = new THREE.ShaderMaterial({\n//           vertexShader: vertexShader,\n//           fragmentShader: fragmentShader,\n//           uniforms: {\n//             ...uniforms,\n//             baseColor: { value: new THREE.Color(0xffffff) }, // White base color for the text\n//           },\n//         });\n\n//         const textMesh = new THREE.Mesh(textGeometry, textMaterial);\n//         textMesh.position.set(0, 0, 0); // Positioned at origin of the group\n\n//         // Add both the text and background to the group\n//         textGroup.add(backgroundMesh);\n//         textGroup.add(textMesh);\n//         textGroup.position.set(xPosition, yPosition, 0); // Adjust the group's overall position\n\n//         // Add the group to the scene\n//         scene.add(textGroup);\n//       }\n//     );\n\n//     // Camera Position\n//     camera.position.z = 5;\n\n//     // Handle window resize\n//     const handleResize = () => {\n//       const width = window.innerWidth;\n//       const height = window.innerHeight;\n//       renderer.setSize(width, height);\n//       camera.aspect = width / height;\n//       camera.updateProjectionMatrix();\n//     };\n//     window.addEventListener('resize', handleResize);\n\n//     // Animate light following the mouse\n//     let mouseX = 0;\n//     let mouseY = 0;\n\n//     const onMouseMove = (event) => {\n//       mouseX = (event.clientX / window.innerWidth) * 2 - 1;\n//       mouseY = -(event.clientY / window.innerHeight) * 2 + 1;\n//     };\n\n//     document.addEventListener('mousemove', onMouseMove);\n\n//     function animate() {\n//       requestAnimationFrame(animate);\n\n//       // Convert the mouse position to 3D coordinates\n//       const vector = new THREE.Vector3(mouseX, mouseY, 0.5);\n//       vector.unproject(camera);\n//       const dir = vector.sub(camera.position).normalize();\n//       const distance = -camera.position.z / dir.z;\n\n//       // Position the light slightly in front of the text\n//       const pos = camera.position.clone().add(dir.multiplyScalar(distance));\n//       pos.z += 1; // Keep the light in front of the text\n//       pointLight.position.copy(pos);\n\n//       // Update the light position uniform for the shader\n//       uniforms.lightPosition.value.copy(pos);\n\n//       renderer.render(scene, camera);\n//     }\n\n//     animate();\n\n//     return () => {\n//       // Clean up event listeners and Three.js resources on component unmount\n//       document.removeEventListener('mousemove', onMouseMove);\n//       window.removeEventListener('resize', handleResize);\n//       mountRef.current.removeChild(renderer.domElement);\n//       renderer.dispose();\n//     };\n//   }, []);\n\n//   return (\n//     <div>\n//       <Navbar />\n//       <div ref={mountRef} style={{ width: '100vw', height: '100vh' }} />\n//     </div>\n//   );\n// }\n\n// export default App;","map":{"version":3,"names":[],"sources":["/Users/abbylui/Documents/GitHub/aboutme/Portfolio/src/App.js"],"sourcesContent":["\n// import React, { useEffect, useRef } from 'react';\n// import * as THREE from 'three';\n// import { FontLoader } from 'three/examples/jsm/loaders/FontLoader.js';\n// import { TextGeometry } from 'three/examples/jsm/geometries/TextGeometry.js';\n// import Navbar from './components/Navbar';\n// import './App.css';\n\n// function App() {\n//   const mountRef = useRef(null);\n\n//   useEffect(() => {\n//     // Vertex Shader\n//     const vertexShader = `\n//       uniform vec3 lightPosition;\n//       varying float vDist;\n\n//       void main() {\n//           vec3 transformedPosition = (modelViewMatrix * vec4(position, 1.0)).xyz;\n\n//           // Calculate the distance from the light source to the vertex\n//           float dist = distance(lightPosition, transformedPosition);\n//           vDist = dist;\n\n//           // Apply a warp based on distance\n//           vec3 direction = normalize(lightPosition - transformedPosition);\n//           vec3 offset = direction * (1.0 / (dist + 0.1)) * 1.2; // Warp effect\n//           transformedPosition += offset;\n\n//           gl_Position = projectionMatrix * vec4(transformedPosition, 1.0);\n//       }\n//     `;\n\n//     // Fragment Shader for Text and Rectangle\n//     const fragmentShader = `\n//       varying float vDist;\n//       uniform vec3 lightColor; // Uniform to receive light color\n//       uniform vec3 baseColor; // Uniform to set the base color (text or rectangle)\n\n//       void main() {\n//           // Calculate intensity based on distance\n//           float intensity = 1.0 / (vDist * vDist + 0.1);\n//           intensity = intensity * 30.0;\n//           intensity = clamp(intensity, 0.0, 1.0);\n\n//           // Apply the light color and intensity to the output color\n//           vec3 color = mix(baseColor, lightColor * intensity, 0.5); // Mix base color with light\n\n//           gl_FragColor = vec4(color, 1.0); // Use the calculated color for the fragment\n//       }\n//     `;\n\n//     // Scene, Camera, Renderer\n//     const scene = new THREE.Scene();\n//     const camera = new THREE.PerspectiveCamera(\n//       75,\n//       window.innerWidth / window.innerHeight,\n//       0.1,\n//       1000\n//     );\n//     const renderer = new THREE.WebGLRenderer({ antialias: true });\n\n//     renderer.setSize(window.innerWidth, window.innerHeight);\n//     mountRef.current.appendChild(renderer.domElement);\n\n//     // Add a point light to act as the dynamic light source\n//     const pointLight = new THREE.PointLight(0xffffff, 2, 100); // White light with increased intensity\n//     pointLight.decay = 1; // Adjust decay for desired falloff\n//     pointLight.castShadow = true;\n//     scene.add(pointLight);\n\n//     // Uniforms for the shader\n//     const uniforms = {\n//       lightPosition: { value: new THREE.Vector3(0, 0, 0) },\n//       lightColor: { value: new THREE.Color(0xffffff) }, // Set light color for interactions\n//     };\n\n//     // Load the font and create the text\n//     const loader = new FontLoader();\n//     loader.load(\n//       'https://threejs.org/examples/fonts/helvetiker_regular.typeface.json',\n//       function (font) {\n//         const textGeometry = new TextGeometry(\n//           'HCI Explorer of digital-physical experiences',\n//           {\n//             font: font,\n//             size: 0.2,\n//             height: 0.0,\n//             curveSegments: 12,\n//             bevelEnabled: false,\n//           }\n//         );\n\n//         textGeometry.computeBoundingBox();\n//         const textWidth =\n//           textGeometry.boundingBox.max.x - textGeometry.boundingBox.min.x;\n//         const textHeight =\n//           textGeometry.boundingBox.max.y - textGeometry.boundingBox.min.y;\n//         const xPosition = -textWidth / 2;\n//         const yPosition = 2.5; // Keep the original vertical position of the text\n\n//         // Create the group for text and background\n//         const textGroup = new THREE.Group();\n\n//         // Create the background rectangle\n//         const backgroundGeometry = new THREE.PlaneGeometry(\n//           textWidth + 0.2, // Slightly larger than the text\n//           textHeight + 0.1\n//         );\n\n//         // Background material using the same shader but with a blue base color\n//         const backgroundMaterial = new THREE.ShaderMaterial({\n//           vertexShader: vertexShader,\n//           fragmentShader: fragmentShader,\n//           uniforms: {\n//             ...uniforms,\n//             baseColor: { value: new THREE.Color(0x000000) }, // Blue base color for the rectangle\n//           },\n//         });\n\n//         const backgroundMesh = new THREE.Mesh(backgroundGeometry, backgroundMaterial);\n//         backgroundMesh.position.set(2.7, 0.1, -0.01); // Adjust the rectangle's position slightly below the text\n\n//         // Text material using the same shader but with a white base color\n//         const textMaterial = new THREE.ShaderMaterial({\n//           vertexShader: vertexShader,\n//           fragmentShader: fragmentShader,\n//           uniforms: {\n//             ...uniforms,\n//             baseColor: { value: new THREE.Color(0xffffff) }, // White base color for the text\n//           },\n//         });\n\n//         const textMesh = new THREE.Mesh(textGeometry, textMaterial);\n//         textMesh.position.set(0, 0, 0); // Positioned at origin of the group\n\n//         // Add both the text and background to the group\n//         textGroup.add(backgroundMesh);\n//         textGroup.add(textMesh);\n//         textGroup.position.set(xPosition, yPosition, 0); // Adjust the group's overall position\n\n//         // Add the group to the scene\n//         scene.add(textGroup);\n//       }\n//     );\n\n//     // Camera Position\n//     camera.position.z = 5;\n\n//     // Handle window resize\n//     const handleResize = () => {\n//       const width = window.innerWidth;\n//       const height = window.innerHeight;\n//       renderer.setSize(width, height);\n//       camera.aspect = width / height;\n//       camera.updateProjectionMatrix();\n//     };\n//     window.addEventListener('resize', handleResize);\n\n//     // Animate light following the mouse\n//     let mouseX = 0;\n//     let mouseY = 0;\n\n//     const onMouseMove = (event) => {\n//       mouseX = (event.clientX / window.innerWidth) * 2 - 1;\n//       mouseY = -(event.clientY / window.innerHeight) * 2 + 1;\n//     };\n\n//     document.addEventListener('mousemove', onMouseMove);\n\n//     function animate() {\n//       requestAnimationFrame(animate);\n\n//       // Convert the mouse position to 3D coordinates\n//       const vector = new THREE.Vector3(mouseX, mouseY, 0.5);\n//       vector.unproject(camera);\n//       const dir = vector.sub(camera.position).normalize();\n//       const distance = -camera.position.z / dir.z;\n\n//       // Position the light slightly in front of the text\n//       const pos = camera.position.clone().add(dir.multiplyScalar(distance));\n//       pos.z += 1; // Keep the light in front of the text\n//       pointLight.position.copy(pos);\n\n//       // Update the light position uniform for the shader\n//       uniforms.lightPosition.value.copy(pos);\n\n//       renderer.render(scene, camera);\n//     }\n\n//     animate();\n\n//     return () => {\n//       // Clean up event listeners and Three.js resources on component unmount\n//       document.removeEventListener('mousemove', onMouseMove);\n//       window.removeEventListener('resize', handleResize);\n//       mountRef.current.removeChild(renderer.domElement);\n//       renderer.dispose();\n//     };\n//   }, []);\n\n//   return (\n//     <div>\n//       <Navbar />\n//       <div ref={mountRef} style={{ width: '100vw', height: '100vh' }} />\n//     </div>\n//   );\n// }\n\n// export default App;"],"mappings":";AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}