{"ast":null,"code":"var _jsxFileName = \"/Users/abbylui/Documents/GitHub/aboutme/Portfolio/src/components/Home.js\",\n  _s = $RefreshSig$();\n// import React, { useEffect, useRef } from 'react';\n// import * as THREE from 'three';\n// import { FontLoader } from 'three/examples/jsm/loaders/FontLoader.js';\n// import { TextGeometry } from 'three/examples/jsm/geometries/TextGeometry.js';\n\n// function Home() {\n//     const mountRef = useRef(null);\n\n//     useEffect(() => {\n//         // Vertex Shader\n//         const vertexShader = `\n//       uniform vec3 lightPosition;\n//       varying float vDist;\n\n//       void main() {\n//           vec3 transformedPosition = (modelViewMatrix * vec4(position, 1.0)).xyz;\n\n//           // Calculate the distance from the light source to the vertex\n//           float dist = distance(lightPosition, transformedPosition);\n//           vDist = dist;\n\n//           // Apply a warp based on distance\n//           vec3 direction = normalize(lightPosition - transformedPosition);\n//           vec3 offset = direction * (1.0 / (dist + 0.1)) * 1.2; // Warp effect\n//           transformedPosition += offset;\n\n//           gl_Position = projectionMatrix * vec4(transformedPosition, 1.0);\n//       }\n//     `;\n\n//         // Fragment Shader\n//         const fragmentShader = `\n//       varying float vDist;\n//       uniform vec3 lightColor; // Uniform to receive light color\n\n//       void main() {\n//           // Calculate intensity based on distance\n//           float intensity = 1.0 / (vDist * vDist + 0.1);\n//           intensity = intensity * 40.0;\n//           intensity = clamp(intensity, 0.0, 1.0);\n\n//           // Apply the light color and intensity to the output color\n//           vec3 color = lightColor * intensity; // Multiply the light color by the intensity\n\n//           gl_FragColor = vec4(color, 1.0); // Use the calculated color for the fragment\n//       }\n//     `;\n\n//         // Scene, Camera, Renderer\n//         const scene = new THREE.Scene();\n//         const camera = new THREE.PerspectiveCamera(\n//             75,\n//             window.innerWidth / window.innerHeight,\n//             0.1,\n//             1000\n//         );\n//         const renderer = new THREE.WebGLRenderer({ antialias: true });\n\n//         renderer.setSize(window.innerWidth, window.innerHeight);\n//         if (mountRef.current) {\n//             mountRef.current.appendChild(renderer.domElement);\n//         }\n\n//         // Add a point light to act as the dynamic light source\n//         const pointLight = new THREE.PointLight(0xffffff, 2, 100);\n//         pointLight.decay = 1;\n//         pointLight.castShadow = false;\n//         scene.add(pointLight);\n\n//         const uniforms = {\n//             lightPosition: { value: new THREE.Vector3(0, 0, 0) },\n//             lightColor: { value: new THREE.Color(0xffffff) },\n//         };\n\n//         const loader = new FontLoader();\n//         loader.load(\n//             'https://threejs.org/examples/fonts/helvetiker_regular.typeface.json',\n//             function (font) {\n//                 const textGeometry = new TextGeometry(\n//                     'Human-computer Interaction Explorer of digital-physical experiences',\n//                     {\n//                         font: font,\n//                         size: 0.2,\n//                         height: 0.0,\n//                         curveSegments: 12,\n//                         bevelEnabled: false,\n//                     }\n//                 );\n\n//                 textGeometry.computeBoundingBox();\n//                 const textWidth =\n//                     textGeometry.boundingBox.max.x - textGeometry.boundingBox.min.x;\n//                 const xPosition = -textWidth / 2;\n\n//                 const textMaterial = new THREE.ShaderMaterial({\n//                     vertexShader: vertexShader,\n//                     fragmentShader: fragmentShader,\n//                     uniforms: uniforms,\n//                 });\n\n//                 const textMesh = new THREE.Mesh(textGeometry, textMaterial);\n//                 textMesh.position.set(xPosition, 2.5, 0);\n//                 textMesh.castShadow = false;\n//                 scene.add(textMesh);\n//             }\n//         );\n\n//         camera.position.z = 5;\n\n//         const handleResize = () => {\n//             const width = window.innerWidth;\n//             const height = window.innerHeight;\n//             renderer.setPixelRatio(window.devicePixelRatio / 2);\n//             renderer.setSize(width, height);\n//             camera.aspect = width / height;\n//             camera.updateProjectionMatrix();\n//         };\n//         window.addEventListener('resize', handleResize);\n\n//         let mouseX = 0;\n//         let mouseY = 0;\n\n//         const onMouseMove = (event) => {\n//             mouseX = (event.clientX / window.innerWidth) * 2 - 1;\n//             mouseY = -(event.clientY / window.innerHeight) * 2 + 1;\n//         };\n\n//         document.addEventListener('mousemove', onMouseMove);\n\n//         function animate() {\n//             requestAnimationFrame(animate);\n\n//             const vector = new THREE.Vector3(mouseX, mouseY, 0.5);\n//             vector.unproject(camera);\n//             const dir = vector.sub(camera.position).normalize();\n//             const distance = -camera.position.z / dir.z;\n\n//             const pos = camera.position.clone().add(dir.multiplyScalar(distance));\n//             pos.z += 1;\n//             pointLight.position.copy(pos);\n\n//             uniforms.lightPosition.value.copy(pos);\n\n//             renderer.render(scene, camera);\n//         }\n\n//         animate();\n\n//         return () => {\n//             document.removeEventListener('mousemove', onMouseMove);\n//             window.removeEventListener('resize', handleResize);\n//             if (mountRef.current) {\n//                 mountRef.current.removeChild(renderer.domElement);\n//             }\n//             renderer.dispose();\n//         };\n//     }, []);\n\n//     return <div ref={mountRef} style={{ width: '100vw', height: '100vh' }} />;\n// }\n\n// export default Home;\n\nimport React, { useEffect, useRef } from 'react';\nimport * as THREE from 'three';\nimport { FontLoader } from 'three/examples/jsm/loaders/FontLoader.js';\nimport { TextGeometry } from 'three/examples/jsm/geometries/TextGeometry.js';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nfunction Home() {\n  _s();\n  const mountRef = useRef(null);\n  useEffect(() => {\n    // Vertex Shader (simplified, only for warp effect)\n    const vertexShader = `\n      varying vec3 vPosition;\n  \n      void main() {\n          vec3 transformedPosition = (modelViewMatrix * vec4(position, 1.0)).xyz;\n\n          // Apply a simple warp effect\n          vec3 offset = vec3(sin(transformedPosition.x * 10.0) * 0.05, 0.0, 0.0);\n          transformedPosition += offset;\n\n          vPosition = transformedPosition;\n          gl_Position = projectionMatrix * vec4(transformedPosition, 1.0);\n      }\n    `;\n\n    // Fragment Shader (simple color without lighting)\n    const fragmentShader = `\n      uniform vec3 baseColor;\n\n      void main() {\n          gl_FragColor = vec4(baseColor, 1.0);\n      }\n    `;\n\n    // Scene, Camera, Renderer\n    const scene = new THREE.Scene();\n    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);\n    const renderer = new THREE.WebGLRenderer({\n      antialias: true\n    });\n    renderer.setSize(window.innerWidth, window.innerHeight);\n    if (mountRef.current) {\n      mountRef.current.appendChild(renderer.domElement);\n    }\n    const uniforms = {\n      baseColor: {\n        value: new THREE.Color(0xffffff)\n      }\n    };\n    const loader = new FontLoader();\n    loader.load('https://threejs.org/examples/fonts/helvetiker_regular.typeface.json', function (font) {\n      const textGeometry = new TextGeometry('Human-computer Interaction Explorer of digital-physical experiences', {\n        font: font,\n        size: 0.2,\n        height: 0.0,\n        curveSegments: 12,\n        bevelEnabled: false\n      });\n      textGeometry.computeBoundingBox();\n      const textWidth = textGeometry.boundingBox.max.x - textGeometry.boundingBox.min.x;\n      const xPosition = -textWidth / 2;\n      const textMaterial = new THREE.ShaderMaterial({\n        vertexShader: vertexShader,\n        fragmentShader: fragmentShader,\n        uniforms: uniforms\n      });\n      const textMesh = new THREE.Mesh(textGeometry, textMaterial);\n      textMesh.position.set(xPosition, 2.5, 0);\n      scene.add(textMesh);\n    });\n    camera.position.z = 5;\n    const handleResize = () => {\n      const width = window.innerWidth;\n      const height = window.innerHeight;\n      renderer.setPixelRatio(window.devicePixelRatio / 2);\n      renderer.setSize(width, height);\n      camera.aspect = width / height;\n      camera.updateProjectionMatrix();\n    };\n    window.addEventListener('resize', handleResize);\n    function animate() {\n      requestAnimationFrame(animate);\n      renderer.render(scene, camera);\n    }\n    animate();\n    return () => {\n      window.removeEventListener('resize', handleResize);\n      if (mountRef.current) {\n        mountRef.current.removeChild(renderer.domElement);\n      }\n      renderer.dispose();\n    };\n  }, []);\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    ref: mountRef,\n    style: {\n      width: '100vw',\n      height: '100vh'\n    }\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 278,\n    columnNumber: 12\n  }, this);\n}\n_s(Home, \"V9/qkEdV8GfsDZk7lMTA1T8g5Ps=\");\n_c = Home;\nexport default Home;\nvar _c;\n$RefreshReg$(_c, \"Home\");","map":{"version":3,"names":["React","useEffect","useRef","THREE","FontLoader","TextGeometry","jsxDEV","_jsxDEV","Home","_s","mountRef","vertexShader","fragmentShader","scene","Scene","camera","PerspectiveCamera","window","innerWidth","innerHeight","renderer","WebGLRenderer","antialias","setSize","current","appendChild","domElement","uniforms","baseColor","value","Color","loader","load","font","textGeometry","size","height","curveSegments","bevelEnabled","computeBoundingBox","textWidth","boundingBox","max","x","min","xPosition","textMaterial","ShaderMaterial","textMesh","Mesh","position","set","add","z","handleResize","width","setPixelRatio","devicePixelRatio","aspect","updateProjectionMatrix","addEventListener","animate","requestAnimationFrame","render","removeEventListener","removeChild","dispose","ref","style","fileName","_jsxFileName","lineNumber","columnNumber","_c","$RefreshReg$"],"sources":["/Users/abbylui/Documents/GitHub/aboutme/Portfolio/src/components/Home.js"],"sourcesContent":["// import React, { useEffect, useRef } from 'react';\n// import * as THREE from 'three';\n// import { FontLoader } from 'three/examples/jsm/loaders/FontLoader.js';\n// import { TextGeometry } from 'three/examples/jsm/geometries/TextGeometry.js';\n\n// function Home() {\n//     const mountRef = useRef(null);\n\n//     useEffect(() => {\n//         // Vertex Shader\n//         const vertexShader = `\n//       uniform vec3 lightPosition;\n//       varying float vDist;\n\n//       void main() {\n//           vec3 transformedPosition = (modelViewMatrix * vec4(position, 1.0)).xyz;\n\n//           // Calculate the distance from the light source to the vertex\n//           float dist = distance(lightPosition, transformedPosition);\n//           vDist = dist;\n\n//           // Apply a warp based on distance\n//           vec3 direction = normalize(lightPosition - transformedPosition);\n//           vec3 offset = direction * (1.0 / (dist + 0.1)) * 1.2; // Warp effect\n//           transformedPosition += offset;\n\n//           gl_Position = projectionMatrix * vec4(transformedPosition, 1.0);\n//       }\n//     `;\n\n//         // Fragment Shader\n//         const fragmentShader = `\n//       varying float vDist;\n//       uniform vec3 lightColor; // Uniform to receive light color\n\n//       void main() {\n//           // Calculate intensity based on distance\n//           float intensity = 1.0 / (vDist * vDist + 0.1);\n//           intensity = intensity * 40.0;\n//           intensity = clamp(intensity, 0.0, 1.0);\n\n//           // Apply the light color and intensity to the output color\n//           vec3 color = lightColor * intensity; // Multiply the light color by the intensity\n\n//           gl_FragColor = vec4(color, 1.0); // Use the calculated color for the fragment\n//       }\n//     `;\n\n//         // Scene, Camera, Renderer\n//         const scene = new THREE.Scene();\n//         const camera = new THREE.PerspectiveCamera(\n//             75,\n//             window.innerWidth / window.innerHeight,\n//             0.1,\n//             1000\n//         );\n//         const renderer = new THREE.WebGLRenderer({ antialias: true });\n\n//         renderer.setSize(window.innerWidth, window.innerHeight);\n//         if (mountRef.current) {\n//             mountRef.current.appendChild(renderer.domElement);\n//         }\n\n//         // Add a point light to act as the dynamic light source\n//         const pointLight = new THREE.PointLight(0xffffff, 2, 100);\n//         pointLight.decay = 1;\n//         pointLight.castShadow = false;\n//         scene.add(pointLight);\n\n//         const uniforms = {\n//             lightPosition: { value: new THREE.Vector3(0, 0, 0) },\n//             lightColor: { value: new THREE.Color(0xffffff) },\n//         };\n\n//         const loader = new FontLoader();\n//         loader.load(\n//             'https://threejs.org/examples/fonts/helvetiker_regular.typeface.json',\n//             function (font) {\n//                 const textGeometry = new TextGeometry(\n//                     'Human-computer Interaction Explorer of digital-physical experiences',\n//                     {\n//                         font: font,\n//                         size: 0.2,\n//                         height: 0.0,\n//                         curveSegments: 12,\n//                         bevelEnabled: false,\n//                     }\n//                 );\n\n//                 textGeometry.computeBoundingBox();\n//                 const textWidth =\n//                     textGeometry.boundingBox.max.x - textGeometry.boundingBox.min.x;\n//                 const xPosition = -textWidth / 2;\n\n//                 const textMaterial = new THREE.ShaderMaterial({\n//                     vertexShader: vertexShader,\n//                     fragmentShader: fragmentShader,\n//                     uniforms: uniforms,\n//                 });\n\n//                 const textMesh = new THREE.Mesh(textGeometry, textMaterial);\n//                 textMesh.position.set(xPosition, 2.5, 0);\n//                 textMesh.castShadow = false;\n//                 scene.add(textMesh);\n//             }\n//         );\n\n//         camera.position.z = 5;\n\n//         const handleResize = () => {\n//             const width = window.innerWidth;\n//             const height = window.innerHeight;\n//             renderer.setPixelRatio(window.devicePixelRatio / 2);\n//             renderer.setSize(width, height);\n//             camera.aspect = width / height;\n//             camera.updateProjectionMatrix();\n//         };\n//         window.addEventListener('resize', handleResize);\n\n//         let mouseX = 0;\n//         let mouseY = 0;\n\n//         const onMouseMove = (event) => {\n//             mouseX = (event.clientX / window.innerWidth) * 2 - 1;\n//             mouseY = -(event.clientY / window.innerHeight) * 2 + 1;\n//         };\n\n//         document.addEventListener('mousemove', onMouseMove);\n\n//         function animate() {\n//             requestAnimationFrame(animate);\n\n//             const vector = new THREE.Vector3(mouseX, mouseY, 0.5);\n//             vector.unproject(camera);\n//             const dir = vector.sub(camera.position).normalize();\n//             const distance = -camera.position.z / dir.z;\n\n//             const pos = camera.position.clone().add(dir.multiplyScalar(distance));\n//             pos.z += 1;\n//             pointLight.position.copy(pos);\n\n//             uniforms.lightPosition.value.copy(pos);\n\n//             renderer.render(scene, camera);\n//         }\n\n//         animate();\n\n//         return () => {\n//             document.removeEventListener('mousemove', onMouseMove);\n//             window.removeEventListener('resize', handleResize);\n//             if (mountRef.current) {\n//                 mountRef.current.removeChild(renderer.domElement);\n//             }\n//             renderer.dispose();\n//         };\n//     }, []);\n\n//     return <div ref={mountRef} style={{ width: '100vw', height: '100vh' }} />;\n// }\n\n// export default Home;\n\n\nimport React, { useEffect, useRef } from 'react';\nimport * as THREE from 'three';\nimport { FontLoader } from 'three/examples/jsm/loaders/FontLoader.js';\nimport { TextGeometry } from 'three/examples/jsm/geometries/TextGeometry.js';\n\nfunction Home() {\n    const mountRef = useRef(null);\n\n    useEffect(() => {\n        // Vertex Shader (simplified, only for warp effect)\n        const vertexShader = `\n      varying vec3 vPosition;\n  \n      void main() {\n          vec3 transformedPosition = (modelViewMatrix * vec4(position, 1.0)).xyz;\n\n          // Apply a simple warp effect\n          vec3 offset = vec3(sin(transformedPosition.x * 10.0) * 0.05, 0.0, 0.0);\n          transformedPosition += offset;\n\n          vPosition = transformedPosition;\n          gl_Position = projectionMatrix * vec4(transformedPosition, 1.0);\n      }\n    `;\n\n        // Fragment Shader (simple color without lighting)\n        const fragmentShader = `\n      uniform vec3 baseColor;\n\n      void main() {\n          gl_FragColor = vec4(baseColor, 1.0);\n      }\n    `;\n\n        // Scene, Camera, Renderer\n        const scene = new THREE.Scene();\n        const camera = new THREE.PerspectiveCamera(\n            75,\n            window.innerWidth / window.innerHeight,\n            0.1,\n            1000\n        );\n        const renderer = new THREE.WebGLRenderer({ antialias: true });\n\n        renderer.setSize(window.innerWidth, window.innerHeight);\n        if (mountRef.current) {\n            mountRef.current.appendChild(renderer.domElement);\n        }\n\n        const uniforms = {\n            baseColor: { value: new THREE.Color(0xffffff) },\n        };\n\n        const loader = new FontLoader();\n        loader.load(\n            'https://threejs.org/examples/fonts/helvetiker_regular.typeface.json',\n            function (font) {\n                const textGeometry = new TextGeometry(\n                    'Human-computer Interaction Explorer of digital-physical experiences',\n                    {\n                        font: font,\n                        size: 0.2,\n                        height: 0.0,\n                        curveSegments: 12,\n                        bevelEnabled: false,\n                    }\n                );\n\n                textGeometry.computeBoundingBox();\n                const textWidth =\n                    textGeometry.boundingBox.max.x - textGeometry.boundingBox.min.x;\n                const xPosition = -textWidth / 2;\n\n                const textMaterial = new THREE.ShaderMaterial({\n                    vertexShader: vertexShader,\n                    fragmentShader: fragmentShader,\n                    uniforms: uniforms,\n                });\n\n                const textMesh = new THREE.Mesh(textGeometry, textMaterial);\n                textMesh.position.set(xPosition, 2.5, 0);\n                scene.add(textMesh);\n            }\n        );\n\n        camera.position.z = 5;\n\n        const handleResize = () => {\n            const width = window.innerWidth;\n            const height = window.innerHeight;\n            renderer.setPixelRatio(window.devicePixelRatio / 2);\n            renderer.setSize(width, height);\n            camera.aspect = width / height;\n            camera.updateProjectionMatrix();\n        };\n        window.addEventListener('resize', handleResize);\n\n        function animate() {\n            requestAnimationFrame(animate);\n            renderer.render(scene, camera);\n        }\n\n        animate();\n\n        return () => {\n            window.removeEventListener('resize', handleResize);\n            if (mountRef.current) {\n                mountRef.current.removeChild(renderer.domElement);\n            }\n            renderer.dispose();\n        };\n    }, []);\n\n    return <div ref={mountRef} style={{ width: '100vw', height: '100vh' }} />;\n}\n\nexport default Home;\n"],"mappings":";;AAAA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAGA,OAAOA,KAAK,IAAIC,SAAS,EAAEC,MAAM,QAAQ,OAAO;AAChD,OAAO,KAAKC,KAAK,MAAM,OAAO;AAC9B,SAASC,UAAU,QAAQ,0CAA0C;AACrE,SAASC,YAAY,QAAQ,+CAA+C;AAAC,SAAAC,MAAA,IAAAC,OAAA;AAE7E,SAASC,IAAIA,CAAA,EAAG;EAAAC,EAAA;EACZ,MAAMC,QAAQ,GAAGR,MAAM,CAAC,IAAI,CAAC;EAE7BD,SAAS,CAAC,MAAM;IACZ;IACA,MAAMU,YAAY,GAAG;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;IAEG;IACA,MAAMC,cAAc,GAAG;AAC/B;AACA;AACA;AACA;AACA;AACA,KAAK;;IAEG;IACA,MAAMC,KAAK,GAAG,IAAIV,KAAK,CAACW,KAAK,CAAC,CAAC;IAC/B,MAAMC,MAAM,GAAG,IAAIZ,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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}